<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta
      http-equiv="Content-Security-Policy"
      content="default-src 'self' 'unsafe-inline' 'unsafe-eval' data: blob: https://cdnjs.cloudflare.com https://cdn.jsdelivr.net https://code.jquery.com https://unpkg.com https://d3js.org https://threejs.org https://cdn.plot.ly https://stackpath.bootstrapcdn.com https://maps.googleapis.com https://cdn.tailwindcss.com https://ajax.googleapis.com https://kit.fontawesome.com https://cdn.datatables.net https://maxcdn.bootstrapcdn.com https://code.highcharts.com https://tako-static-assets-production.s3.amazonaws.com https://www.youtube.com https://fonts.googleapis.com https://fonts.gstatic.com https://pfst.cf2.poecdn.net https://puc.poecdn.net https://i.imgur.com https://wikimedia.org https://*.icons8.com https://*.giphy.com https://picsum.photos https://images.unsplash.com; frame-src 'self' https://www.youtube.com https://trytako.com; child-src 'self'; manifest-src 'self'; worker-src 'self'; upgrade-insecure-requests; block-all-mixed-content;"
    />
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>英文回译训练</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <style>
      @media (prefers-color-scheme: dark) {
        :root {
          --bg-primary: #181818;
          --text-primary: #e5e5e5;
          --bg-secondary: #262626;
          --border-color: #404040;
          --highlight-bg: #2d2d5d;
          --primary-color: #5d5cde;
          --primary-light: #7e7df0;
        }
      }

      @media (prefers-color-scheme: light) {
        :root {
          --bg-primary: #ffffff;
          --text-primary: #333333;
          --bg-secondary: #f5f5f5;
          --border-color: #e0e0e0;
          --highlight-bg: #ececf8;
          --primary-color: #5d5cde;
          --primary-light: #7e7df0;
        }
      }

      body {
        background-color: var(--bg-primary);
        color: var(--text-primary);
        font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
          Roboto, sans-serif;
      }

      .app-container {
        max-width: 800px;
        margin: 0 auto;
        padding: 1rem;
      }

      .card {
        background-color: var(--bg-secondary);
        border: 1px solid var(--border-color);
        border-radius: 0.5rem;
        padding: 1.5rem;
        margin-bottom: 1.5rem;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
      }

      .btn {
        background-color: var(--primary-color);
        color: white;
        padding: 0.5rem 1rem;
        border-radius: 0.25rem;
        font-weight: 500;
        cursor: pointer;
        transition: background-color 0.2s ease;
      }

      .btn:hover {
        background-color: var(--primary-light);
      }

      .btn:disabled {
        background-color: #9ca3af;
        cursor: not-allowed;
      }

      textarea,
      input {
        background-color: var(--bg-primary);
        color: var(--text-primary);
        border: 1px solid var(--border-color);
        border-radius: 0.25rem;
        padding: 0.75rem;
        font-size: 16px;
        line-height: 1.5;
        width: 100%;
        resize: vertical;
      }

      textarea:focus,
      input:focus {
        outline: 2px solid var(--primary-color);
      }

      .text-chunk {
        background-color: var(--highlight-bg);
        padding: 0.75rem;
        border-radius: 0.25rem;
        margin-bottom: 0.5rem;
        line-height: 1.6;
      }

      .comparison-item {
        border-left: 3px solid var(--primary-color);
        padding-left: 1rem;
        margin-bottom: 1.5rem;
      }

      @keyframes fadeIn {
        from {
          opacity: 0;
        }
        to {
          opacity: 1;
        }
      }

      .fade-in {
        animation: fadeIn 0.5s ease-in-out;
      }

      .step-indicator {
        display: flex;
        justify-content: space-between;
        margin-bottom: 2rem;
      }

      .step {
        flex: 1;
        text-align: center;
        padding: 0.5rem;
      }

      .step.active {
        font-weight: bold;
        color: var(--primary-color);
        border-bottom: 2px solid var(--primary-color);
      }

      .chunk-counter {
        font-size: 0.75rem;
        color: #9ca3af;
        text-align: right;
        margin-bottom: 0.25rem;
      }

      .progress-bar-container {
        width: 100%;
        height: 0.5rem;
        background-color: var(--border-color);
        border-radius: 0.25rem;
        margin-bottom: 1rem;
      }

      .progress-bar {
        height: 100%;
        background-color: var(--primary-color);
        border-radius: 0.25rem;
        transition: width 0.3s ease;
      }
    </style>
  </head>
  <body>
    <div class="app-container">
      <h1 class="text-2xl font-bold mb-6 text-center">英文回译训练</h1>

      <div class="step-indicator">
        <div id="step1" class="step active">1. 输入文章</div>
        <div id="step2" class="step">2. 英译中</div>
        <div id="step3" class="step">3. 中译英</div>
        <div id="step4" class="step">4. 对比分析</div>
      </div>

      <div id="inputSection" class="card fade-in">
        <h2 class="text-xl font-semibold mb-4">输入英文文章</h2>
        <p class="mb-4">
          请输入您要用于回译训练的英文文章。系统将自动将文章分割成小块以便于翻译。
        </p>
        <textarea
          id="originalText"
          class="mb-4"
          rows="10"
          placeholder="在此粘贴英文文章..."
        ></textarea>
        <div class="flex justify-between">
          <button id="demoBtn" class="btn bg-gray-500 mr-2">快速演示</button>
          <button id="startBtn" class="btn">开始训练</button>
        </div>
      </div>

      <div id="translationSection" class="hidden">
        <div class="progress-bar-container">
          <div
            id="translationProgress"
            class="progress-bar"
            style="width: 0%"
          ></div>
        </div>
        <div id="chunkInfo" class="mb-2 text-sm"></div>
        <div id="translationChunks"></div>
        <div class="flex justify-between mt-4">
          <button id="prevTransBtn" class="btn bg-gray-500">上一段</button>
          <button id="backToInputBtn" class="btn bg-gray-500">返回输入</button>
          <button id="nextTransBtn" class="btn">下一段</button>
        </div>
        <div class="mt-4">
          <button id="finishTransBtn" class="btn w-full hidden">
            完成翻译，进入回译阶段
          </button>
        </div>
      </div>

      <div id="backTranslationSection" class="hidden">
        <div class="progress-bar-container">
          <div
            id="backTranslationProgress"
            class="progress-bar"
            style="width: 0%"
          ></div>
        </div>
        <div id="backChunkInfo" class="mb-2 text-sm"></div>
        <div id="backTranslationChunks"></div>
        <div class="flex justify-between mt-4">
          <button id="prevBackBtn" class="btn bg-gray-500">上一段</button>
          <button id="backToInputBtn" class="btn bg-gray-500">返回输入</button>
          <button id="nextBackBtn" class="btn">下一段</button>
        </div>
        <div class="mt-4">
          <button id="finishBackBtn" class="btn w-full hidden">
            完成回译，查看对比结果
          </button>
        </div>
      </div>

      <div id="comparisonSection" class="hidden">
        <div class="card">
          <h2 class="text-xl font-semibold mb-4">回译对比分析</h2>
          <p class="mb-4">
            通过对比原文和回译文本，您可以发现自己在表达方式、用词选择和语法结构上的差异。
          </p>
          <div id="comparisonResults"></div>
          <div class="mt-4 flex flex-wrap gap-2">
            <button id="exportBtn" class="btn bg-blue-600 flex-1">
              导出训练结果
            </button>
            <button id="newSessionBtn" class="btn flex-1">开始新的训练</button>
          </div>
        </div>
      </div>

      <div id="historySection" class="hidden">
        <div class="card">
          <div id="historyList" class="divide-y divide-gray-200 dark:divide-gray-700">
            <!-- 历史记录将在这里动态生成 -->
          </div>
        </div>
      </div>
    </div>

    <script>
      // 示例文本（用于快速演示）
      const demoText = `Learning a new language is a journey that requires patience and practice. 
It opens doors to new cultures and perspectives. 
Research shows that bilingual people have better cognitive abilities.
Regular practice is the key to success in language learning.`;

      const demoTranslations = [
        "学习一门新语言是一段需要耐心和练习的旅程。",
        "它为新的文化和视角打开了大门。",
        "研究表明，双语人士拥有更好的认知能力。",
        "定期练习是语言学习成功的关键。",
      ];

      const demoBackTranslations = [
        "Learning a new language is a journey that needs patience and practice.",
        "It opens doors to new cultures and perspectives.",
        "Studies show that bilingual people have better cognitive abilities.",
        "Regular practice is the key to success in language learning.",
      ];

      // 数据存储相关函数
      const storage = {
        // 保存训练记录
        saveTrainingRecord: function (record) {
          // 获取现有记录列表
          const records = this.getAllRecords();

          // 添加新记录
          records[record.id] = record;

          // 保存回本地存储
          localStorage.setItem("trainingRecords", JSON.stringify(records));
        },

        // 获取特定训练记录
        getRecord: function (id) {
          const records = this.getAllRecords();
          return records[id] || null;
        },

        // 获取所有训练记录
        getAllRecords: function () {
          const recordsString = localStorage.getItem("trainingRecords");
          return recordsString ? JSON.parse(recordsString) : {};
        },

        // 删除训练记录
        deleteRecord: function (id) {
          const records = this.getAllRecords();
          if (records[id]) {
            delete records[id];
            localStorage.setItem("trainingRecords", JSON.stringify(records));
            return true;
          }
          return false;
        },
      };

      // 状态管理
      const state = {
        recordId: null, // 当前记录的ID
        originalText: "",
        chunks: [],
        translations: [],
        backTranslations: [],
        currentChunkIndex: 0,
        currentStep: 1,
      };

      // DOM 元素
      const elements = {
        inputSection: document.getElementById("inputSection"),
        translationSection: document.getElementById("translationSection"),
        backTranslationSection: document.getElementById(
          "backTranslationSection"
        ),
        comparisonSection: document.getElementById("comparisonSection"),
        originalText: document.getElementById("originalText"),
        startBtn: document.getElementById("startBtn"),
        translationChunks: document.getElementById("translationChunks"),
        backTranslationChunks: document.getElementById("backTranslationChunks"),
        comparisonResults: document.getElementById("comparisonResults"),
        prevTransBtn: document.getElementById("prevTransBtn"),
        nextTransBtn: document.getElementById("nextTransBtn"),
        finishTransBtn: document.getElementById("finishTransBtn"),
        prevBackBtn: document.getElementById("prevBackBtn"),
        nextBackBtn: document.getElementById("nextBackBtn"),
        finishBackBtn: document.getElementById("finishBackBtn"),
        newSessionBtn: document.getElementById("newSessionBtn"),
        stepIndicators: [
          document.getElementById("step1"),
          document.getElementById("step2"),
          document.getElementById("step3"),
          document.getElementById("step4"),
        ],
        translationProgress: document.getElementById("translationProgress"),
        backTranslationProgress: document.getElementById(
          "backTranslationProgress"
        ),
        chunkInfo: document.getElementById("chunkInfo"),
        backChunkInfo: document.getElementById("backChunkInfo"),
        historySection: document.getElementById("historySection"),
        historyList: document.getElementById("historyList"),
        backToHistoryBtn: document.getElementById("backToHistoryBtn"),
      };

      // 优化的文本分块函数，保持完整性的同时使块长度更均匀
      function splitTextIntoChunks(text) {
        if (!text || text.trim() === "") return [];

        // 更全面的缩写列表，确保所有常见缩写都被处理
        const abbreviations = [
          "Mr.",
          "Mrs.",
          "Ms.",
          "Dr.",
          "Prof.",
          "Rev.",
          "St.",
          "Jr.",
          "Sr.",
          "e.g.",
          "i.e.",
          "etc.",
          "vs.",
          "U.S.",
          "U.K.",
          "Ph.D.",
          "M.D.",
          "B.A.",
          "M.A.",
          "a.m.",
          "p.m.",
          "No.",
          "Vol.",
          "Jan.",
          "Feb.",
          "Mar.",
          "Apr.",
          "Jun.",
          "Jul.",
          "Aug.",
          "Sept.",
          "Oct.",
          "Nov.",
          "Dec.",
          "Dept.",
          "Univ.",
          "Bros.",
          "Inc.",
          "Ltd.",
          "Co.",
          "Corp.",
          "Ave.",
          "Blvd.",
          "Rd.",
          "Fig.",
          "Gov.",
          "Hon.",
        ];

        // 创建一个临时占位符映射
        const placeholders = {};
        let tempText = text;

        // 替换所有缩写
        abbreviations.forEach((abbr, index) => {
          const placeholder = `__ABBR_${index}__`;
          const regex = new RegExp(abbr.replace(/\./g, "\\."), "g");
          tempText = tempText.replace(regex, placeholder);
          placeholders[placeholder] = abbr;
        });

        // 处理数字小数点和页码
        tempText = tempText
          .replace(/(\d+)\.(\d+)/g, "$1__DECIMAL__$2") // 处理小数点
          .replace(/p\.\s*\d+/g, (match) => match.replace(".", "__PAGE__")); // 处理页码

        // 按段落分割
        const paragraphs = tempText.split(/\n\s*\n|\r\n\s*\r\n/);
        const chunks = [];

        // 设置块长度参数
        const MIN_CHUNK_LENGTH = 80; // 最小块长度
        const IDEAL_CHUNK_LENGTH = 200; // 理想块长度
        const MAX_CHUNK_LENGTH = 300; // 最大块长度

        paragraphs.forEach((paragraph) => {
          if (!paragraph.trim()) return;

          // 分割成句子
          const sentences = paragraph.match(/[^.!?]+[.!?]+(?=\s|$)/g) || [
            paragraph,
          ];

          // 如果句子划分不完整，用整个段落作为一个块
          if (sentences.join("").length < paragraph.length * 0.9) {
            chunks.push(restoreText(paragraph.trim(), placeholders));
            return;
          }

          // 如果段落很短，直接作为一个块
          if (paragraph.length < MIN_CHUNK_LENGTH) {
            chunks.push(restoreText(paragraph.trim(), placeholders));
            return;
          }

          let currentChunk = "";

          for (let i = 0; i < sentences.length; i++) {
            const sentence = sentences[i].trim();
            const nextSentence =
              i + 1 < sentences.length ? sentences[i + 1].trim() : null;

            // 单独处理特别长的句子
            if (sentence.length > MAX_CHUNK_LENGTH) {
              if (currentChunk) {
                chunks.push(restoreText(currentChunk.trim(), placeholders));
                currentChunk = "";
              }
              chunks.push(restoreText(sentence, placeholders));
              continue;
            }

            // 如果当前块为空，始终添加当前句子
            if (!currentChunk) {
              currentChunk = sentence;
              continue;
            }

            // 计算如果添加当前句子后的块长度
            const potentialLength = currentChunk.length + 1 + sentence.length;

            // 判断是否应该创建新块的智能逻辑
            const isLastSentence = i === sentences.length - 1;

            if (!isLastSentence) {
              // 如果添加这个句子会超过最大长度，创建新块
              if (potentialLength > MAX_CHUNK_LENGTH) {
                chunks.push(restoreText(currentChunk.trim(), placeholders));
                currentChunk = sentence;
                continue;
              }

              // 如果当前块已接近理想长度，并且有多个句子，创建新块
              if (
                currentChunk.length > IDEAL_CHUNK_LENGTH &&
                potentialLength > IDEAL_CHUNK_LENGTH * 1.2
              ) {
                chunks.push(restoreText(currentChunk.trim(), placeholders));
                currentChunk = sentence;
                continue;
              }

              // 如果下一个句子很长，可能更适合单独成块，则提前结束当前块
              if (
                nextSentence &&
                nextSentence.length > IDEAL_CHUNK_LENGTH * 0.7 &&
                potentialLength > IDEAL_CHUNK_LENGTH
              ) {
                chunks.push(restoreText(currentChunk.trim(), placeholders));
                currentChunk = sentence;
                continue;
              }
            }

            // 如果以上条件都不满足，将句子添加到当前块
            currentChunk += " " + sentence;
          }

          // 添加剩余内容
          if (currentChunk) {
            chunks.push(restoreText(currentChunk.trim(), placeholders));
          }
        });

        // 后处理：合并过短的块（如可能的话）
        const finalChunks = [];
        for (let i = 0; i < chunks.length; i++) {
          const chunk = chunks[i];

          // 如果是最后一个块，或者当前块不太短，直接添加
          if (i === chunks.length - 1 || chunk.length >= MIN_CHUNK_LENGTH) {
            finalChunks.push(chunk);
            continue;
          }

          // 尝试与下一个块合并，如果合并后不会太长
          const nextChunk = chunks[i + 1];
          if (chunk.length + nextChunk.length + 1 <= MAX_CHUNK_LENGTH) {
            finalChunks.push(chunk + " " + nextChunk);
            i++; // 跳过下一个块，因为已经合并了
          } else {
            finalChunks.push(chunk);
          }
        }

        // 恢复原始文本的辅助函数
        function restoreText(text, mapping) {
          let result = text;
          // 恢复所有缩写
          for (const [placeholder, original] of Object.entries(mapping)) {
            result = result.replace(new RegExp(placeholder, "g"), original);
          }
          // 恢复数字小数点和页码
          result = result
            .replace(/__DECIMAL__/g, ".")
            .replace(/__PAGE__/g, ".");
          return result;
        }

        return finalChunks;
      }

      // 更新进度条和信息
      function updateProgress(progressBar, infoElement, current, total) {
        const percentage = (current / total) * 100;
        progressBar.style.width = `${percentage}%`;
        infoElement.textContent = `进度: ${current}/${total} (${Math.round(
          percentage
        )}%)`;
      }

      // 切换步骤
      function switchToStep(step) {
        state.currentStep = step;

        // 更新步骤指示器
        elements.stepIndicators.forEach((indicator, index) => {
          if (index + 1 === step) {
            indicator.classList.add("active");
          } else {
            indicator.classList.remove("active");
          }
        });

        // 隐藏所有部分
        elements.inputSection.classList.add("hidden");
        elements.translationSection.classList.add("hidden");
        elements.backTranslationSection.classList.add("hidden");
        elements.comparisonSection.classList.add("hidden");
        elements.historySection.classList.add("hidden");

        // 显示当前步骤
        switch (step) {
          case 0:
            elements.historySection.classList.remove("hidden");
            renderTrainingHistory();
            break;
          case 1:
            elements.inputSection.classList.remove("hidden");
            break;
          case 2:
            elements.translationSection.classList.remove("hidden");
            renderTranslationChunks();
            break;
          case 3:
            elements.backTranslationSection.classList.remove("hidden");
            renderBackTranslationChunks();
            break;
          case 4:
            elements.comparisonSection.classList.remove("hidden");
            renderComparisonResults();
            break;
        }

        // 更新导航栏按钮状态
        updateNavigationBar();
      }

      // 修改updateNavigationBar函数，防止历史按钮重复添加
      function updateNavigationBar() {
        // 根据当前状态判断哪些步骤可以导航
        const completedTranslation =
          state.translations.filter((t) => t && t.trim()).length ===
          state.chunks.length;
        const completedBackTranslation =
          state.backTranslations.filter((t) => t && t.trim()).length ===
          state.chunks.length;

        // 使所有步骤指示器可点击
        elements.stepIndicators.forEach((indicator, index) => {
          // 清除之前的事件监听器
          indicator.replaceWith(indicator.cloneNode(true));

          // 获取新的引用
          elements.stepIndicators[index] = document.getElementById(
            `step${index + 1}`
          );

          const stepNum = index + 1;
          // 添加条件：步骤1总是可点击；步骤2需要有内容；步骤3需要完成翻译；步骤4需要完成回译
          if (
            stepNum === 1 ||
            (stepNum === 2 && state.chunks.length > 0) ||
            (stepNum === 3 && completedTranslation) ||
            (stepNum === 4 && completedBackTranslation)
          ) {
            // 可点击的样式
            elements.stepIndicators[index].style.cursor = "pointer";

            // 添加点击事件
            elements.stepIndicators[index].addEventListener("click", () => {
              // 保存当前步骤的数据
              saveCurrentStepData();

              // 切换到点击的步骤
              switchToStep(stepNum);
            });
          } else {
            // 不可点击的样式
            elements.stepIndicators[index].style.cursor = "not-allowed";
            elements.stepIndicators[index].style.opacity = "0.6";
          }
        });

        // 先移除任何已有的历史按钮
        const existingHistoryStep = document.getElementById("step0");
        if (existingHistoryStep) {
          existingHistoryStep.remove();
        }

        // 添加返回历史记录的选项（如果在步骤1-4）
        if (state.currentStep >= 1 && state.currentStep <= 4) {
          const historyStepIndicator = document.createElement("div");
          historyStepIndicator.id = "step0";
          historyStepIndicator.className = "step";
          historyStepIndicator.textContent = "历史";
          historyStepIndicator.style.cursor = "pointer";
          historyStepIndicator.addEventListener("click", () => {
            saveCurrentTraining();
            switchToStep(0);
          });

          // 添加到导航栏的最前面
          const stepIndicatorContainer =
            document.querySelector(".step-indicator");
          stepIndicatorContainer.insertBefore(
            historyStepIndicator,
            stepIndicatorContainer.firstChild
          );
        }
      }

      // 保存当前步骤的数据
      function saveCurrentStepData() {
        // 根据当前步骤保存数据
        switch (state.currentStep) {
          case 1:
            state.originalText = elements.originalText.value.trim();
            break;
          case 2:
            // 保存当前翻译
            const translationInput =
              document.querySelector(".translation-input");
            if (translationInput) {
              state.translations[state.currentChunkIndex] =
                translationInput.value;
            }
            break;
          case 3:
            // 保存当前回译
            const backTranslationInput = document.querySelector(
              ".back-translation-input"
            );
            if (backTranslationInput) {
              state.backTranslations[state.currentChunkIndex] =
                backTranslationInput.value;
            }
            break;
        }
      }

      // 渲染翻译界面
      function renderTranslationChunks() {
        const chunkIndex = state.currentChunkIndex;
        const chunk = state.chunks[chunkIndex];

        elements.translationChunks.innerHTML = `
                <div class="chunk-counter">${chunkIndex + 1}/${
          state.chunks.length
        }</div>
                <div class="text-chunk">${chunk}</div>
                <textarea 
                    class="translation-input mb-2" 
                    rows="4" 
                    placeholder="请输入此段的中文翻译..."
                >${state.translations[chunkIndex] || ""}</textarea>
            `;

        // 更新进度条
        updateProgress(
          elements.translationProgress,
          elements.chunkInfo,
          chunkIndex + 1,
          state.chunks.length
        );

        // 更新按钮状态
        elements.prevTransBtn.disabled = chunkIndex === 0;
        elements.nextTransBtn.textContent =
          chunkIndex === state.chunks.length - 1 ? "完成" : "下一段";

        // 显示或隐藏"完成翻译"按钮
        if (
          state.translations.filter((t) => t && t.trim()).length ===
          state.chunks.length
        ) {
          elements.finishTransBtn.classList.remove("hidden");
        } else {
          elements.finishTransBtn.classList.add("hidden");
        }

        // 聚焦到文本框
        document.querySelector(".translation-input").focus();
      }

      // 渲染回译界面
      function renderBackTranslationChunks() {
        const chunkIndex = state.currentChunkIndex;
        const originalChunk = state.chunks[chunkIndex];
        const translation = state.translations[chunkIndex];

        elements.backTranslationChunks.innerHTML = `
                <div class="chunk-counter">${chunkIndex + 1}/${
          state.chunks.length
        }</div>
                <div class="mb-2 text-sm text-gray-500">您的中文翻译：</div>
                <div class="text-chunk">${translation}</div>
                <div class="mb-2 text-sm text-gray-500">请将上面的中文回译为英文：</div>
                <textarea 
                    class="back-translation-input" 
                    rows="4" 
                    placeholder="请输入回译的英文..."
                >${state.backTranslations[chunkIndex] || ""}</textarea>
            `;

        // 更新进度条
        updateProgress(
          elements.backTranslationProgress,
          elements.backChunkInfo,
          chunkIndex + 1,
          state.chunks.length
        );

        // 更新按钮状态
        elements.prevBackBtn.disabled = chunkIndex === 0;
        elements.nextBackBtn.textContent =
          chunkIndex === state.chunks.length - 1 ? "完成" : "下一段";

        // 显示或隐藏"完成回译"按钮
        if (
          state.backTranslations.filter((t) => t && t.trim()).length ===
          state.chunks.length
        ) {
          elements.finishBackBtn.classList.remove("hidden");
        } else {
          elements.finishBackBtn.classList.add("hidden");
        }

        // 聚焦到文本框
        document.querySelector(".back-translation-input").focus();
      }

      // 修复对比功能，保留原始的逐句对比设计
      function renderComparisonResults() {
        // 首先检查数据完整性
        if (
          !state.chunks ||
          !state.backTranslations ||
          state.chunks.length === 0 ||
          state.backTranslations.length !== state.chunks.length
        ) {
          elements.comparisonResults.innerHTML =
            '<div class="p-4 text-center text-gray-500">未找到可比较的内容。请确保训练已完成。</div>';

          console.error("比较数据不完整:", {
            chunksLength: state.chunks?.length || 0,
            backTranslationsLength: state.backTranslations?.length || 0,
          });
          return;
        }

        // 将原始文本按句子拆分 - 使用原始块数据而不是整个文本
        let allOriginalSentences = [];
        let allBackSentences = [];

        // 逐段处理，确保句子对应关系正确
        for (let i = 0; i < state.chunks.length; i++) {
          const originalChunk = state.chunks[i];
          const backChunk = state.backTranslations[i];

          if (!originalChunk || !backChunk) continue;

          const originalSentences = extractSentences(originalChunk);
          const backSentences = extractSentences(backChunk);

          // 将段落中的句子添加到总列表，添加段落标记
          originalSentences.forEach((sentence) => {
            allOriginalSentences.push({
              text: sentence,
              paragraphIndex: i,
            });
          });

          backSentences.forEach((sentence) => {
            allBackSentences.push({
              text: sentence,
              paragraphIndex: i,
            });
          });
        }

        console.log("原文句子数:", allOriginalSentences.length);
        console.log("回译句子数:", allBackSentences.length);

        let html = "";

        // 确定要比较的句子数量
        const sentenceCount = Math.min(
          allOriginalSentences.length,
          allBackSentences.length
        );

        // 如果没有句子可比较，显示提示信息
        if (sentenceCount === 0) {
          html =
            '<div class="p-4 text-center text-gray-500">未找到可比较的内容。请确保训练已完成。</div>';
        } else {
          // 分段显示比较结果
          let currentParagraph = -1;

          for (let i = 0; i < sentenceCount; i++) {
            const originalSentence = allOriginalSentences[i].text.trim();
            const backSentence = allBackSentences[i].text.trim();
            const paragraphIndex = allOriginalSentences[i].paragraphIndex;

            // 如果是新段落的开始，添加段落标记
            if (paragraphIndex !== currentParagraph) {
              currentParagraph = paragraphIndex;
              html += `
                <div class="py-2 my-2 border-t border-gray-200 dark:border-gray-700">
                  <div class="font-medium text-sm text-gray-500">段落 ${
                    paragraphIndex + 1
                  }</div>
                </div>
              `;
            }

            html += `
              <div class="comparison-item py-2">
                <div class="mb-2">
                  <span class="text-sm text-gray-500">原文：</span>
                  <span>${originalSentence}</span>
                </div>
                <div>
                  <span class="text-sm text-gray-500">回译：</span>
                  <span>${backSentence}</span>
                </div>
              </div>
            `;
          }

          // 添加完成信息
          html += `
            <div class="mt-6 pt-4 border-t border-gray-200 dark:border-gray-700 text-center text-gray-500">
              <p>训练已完成 - 共${state.chunks.length}个段落，${sentenceCount}个句子</p>
            </div>
          `;
        }

        elements.comparisonResults.innerHTML = html;
        
        // 在渲染完成后重新绑定导出按钮事件
        document.getElementById("exportBtn").addEventListener("click", function() {
          showExportPreview();
        });
        
        // 确保新训练按钮也有事件绑定
        document.getElementById("newSessionBtn").addEventListener("click", function() {
          initializeNewTraining();
        });
      }

      // 提取句子
      function extractSentences(text) {
        if (!text) return [];

        // 预处理文本，处理常见缩写
        const preprocessed = text
          .replace(/Mr\./g, "Mr_DOT_")
          .replace(/Mrs\./g, "Mrs_DOT_")
          .replace(/Ms\./g, "Ms_DOT_")
          .replace(/Dr\./g, "Dr_DOT_")
          .replace(/Prof\./g, "Prof_DOT_")
          .replace(/St\./g, "St_DOT_")
          .replace(/Jr\./g, "Jr_DOT_")
          .replace(/Sr\./g, "Sr_DOT_")
          .replace(/e\.g\./g, "e_DOT_g_DOT_")
          .replace(/i\.e\./g, "i_DOT_e_DOT_")
          .replace(/etc\./g, "etc_DOT_")
          .replace(/vs\./g, "vs_DOT_")
          .replace(/U\.S\./g, "U_DOT_S_DOT_")
          .replace(/U\.K\./g, "U_DOT_K_DOT_")
          .replace(/Ph\.D\./g, "Ph_DOT_D_DOT_")
          .replace(/p\.\s*\d+/g, (match) => match.replace(".", "_DOT_")) // 处理页码 p.123
          .replace(/(\d+)\.(\d+)/g, "$1_DOT_$2"); // 处理小数点 3.14

        // 按句子分割
        const sentencesRaw =
          preprocessed.match(/[^.!?]+[.!?]+|\s*\n\s*|\s*\r\n\s*/g) || [];

        // 还原临时替换的缩写
        return sentencesRaw.map((sentence) =>
          sentence
            .replace(/Mr_DOT_/g, "Mr.")
            .replace(/Mrs_DOT_/g, "Mrs.")
            .replace(/Ms_DOT_/g, "Ms.")
            .replace(/Dr_DOT_/g, "Dr.")
            .replace(/Prof_DOT_/g, "Prof.")
            .replace(/St_DOT_/g, "St.")
            .replace(/Jr_DOT_/g, "Jr.")
            .replace(/Sr_DOT_/g, "Sr.")
            .replace(/e_DOT_g_DOT_/g, "e.g.")
            .replace(/i_DOT_e_DOT_/g, "i.e.")
            .replace(/etc_DOT_/g, "etc.")
            .replace(/vs_DOT_/g, "vs.")
            .replace(/U_DOT_S_DOT_/g, "U.S.")
            .replace(/U_DOT_K_DOT_/g, "U.K.")
            .replace(/Ph_DOT_D_DOT_/g, "Ph.D.")
            .replace(/p_DOT_(\d+)/g, "p.$1")
            .replace(/(\d+)_DOT_(\d+)/g, "$1.$2")
            .trim()
        );
      }

      // 事件处理函数

      // 开始训练
      elements.startBtn.addEventListener("click", () => {
        const text = elements.originalText.value.trim();

        if (!text) {
          alert("请输入英文文章内容");
          return;
        }

        // 创建新训练
        state.recordId = null; // 重置记录ID，将创建新记录
        state.originalText = text;
        state.chunks = splitTextIntoChunks(text);
        state.translations = new Array(state.chunks.length).fill("");
        state.backTranslations = new Array(state.chunks.length).fill("");
        state.currentChunkIndex = 0;

        saveCurrentStepData();
        saveCurrentTraining(); // 保存新训练记录
        switchToStep(2);
      });

      // 快速演示
      document.getElementById("demoBtn").addEventListener("click", () => {
        // 填充演示文本
        elements.originalText.value = demoText;

        // 设置状态
        state.originalText = demoText;
        state.chunks = splitTextIntoChunks(demoText);
        state.translations = [...demoTranslations];
        state.backTranslations = [...demoBackTranslations];
        state.currentChunkIndex = 0;

        // 直接跳到对比分析结果页面
        switchToStep(4);
      });

      // 翻译阶段 - 上一段
      elements.prevTransBtn.addEventListener("click", () => {
        // 保存当前翻译
        const translationInput = document.querySelector(".translation-input");
        state.translations[state.currentChunkIndex] = translationInput.value;

        // 移动到上一段
        state.currentChunkIndex--;
        renderTranslationChunks();
      });

      // 翻译阶段 - 下一段
      elements.nextTransBtn.addEventListener("click", () => {
        // 保存当前翻译
        const translationInput = document.querySelector(".translation-input");
        state.translations[state.currentChunkIndex] = translationInput.value;

        // 移动到下一段或完成
        if (state.currentChunkIndex < state.chunks.length - 1) {
          state.currentChunkIndex++;
          renderTranslationChunks();
        } else {
          // 检查所有翻译是否已完成
          const allTranslated = state.translations.every((t) => t && t.trim());
          if (allTranslated) {
            // 先切换步骤，确保当前状态已保存
            switchToStep(3);
            // 然后再重置索引
            state.currentChunkIndex = 0;
            // 重新渲染回译界面
            renderBackTranslationChunks();
          } else {
            alert("请完成所有段落的翻译");
          }
        }

        // 添加自动保存
        saveCurrentTraining();
      });

      // 完成翻译
      elements.finishTransBtn.addEventListener("click", () => {
        // 保存当前翻译
        const translationInput = document.querySelector(".translation-input");
        state.translations[state.currentChunkIndex] = translationInput.value;

        // 检查所有翻译是否已完成
        const allTranslated = state.translations.every((t) => t && t.trim());
        if (allTranslated) {
          // 先切换步骤，确保当前状态已保存
          switchToStep(3);
          // 然后再重置索引
          state.currentChunkIndex = 0;
          // 重新渲染回译界面
          renderBackTranslationChunks();
        } else {
          alert("请完成所有段落的翻译");
        }
      });

      // 回译阶段 - 上一段
      elements.prevBackBtn.addEventListener("click", () => {
        // 保存当前回译
        const backTranslationInput = document.querySelector(
          ".back-translation-input"
        );
        state.backTranslations[state.currentChunkIndex] =
          backTranslationInput.value;

        // 移动到上一段
        state.currentChunkIndex--;
        renderBackTranslationChunks();
      });

      // 回译阶段 - 下一段
      elements.nextBackBtn.addEventListener("click", () => {
        // 保存当前回译
        const backTranslationInput = document.querySelector(
          ".back-translation-input"
        );
        state.backTranslations[state.currentChunkIndex] =
          backTranslationInput.value;

        // 移动到下一段或完成
        if (state.currentChunkIndex < state.chunks.length - 1) {
          state.currentChunkIndex++;
          renderBackTranslationChunks();
        } else {
          // 检查所有回译是否已完成
          const allBackTranslated = state.backTranslations.every(
            (t) => t && t.trim()
          );
          if (allBackTranslated) {
            switchToStep(4);
          } else {
            alert("请完成所有段落的回译");
          }
        }
      });

      // 完成回译
      elements.finishBackBtn.addEventListener("click", () => {
        // 保存当前回译
        const backTranslationInput = document.querySelector(
          ".back-translation-input"
        );
        state.backTranslations[state.currentChunkIndex] =
          backTranslationInput.value;

        // 检查所有回译是否已完成
        const allBackTranslated = state.backTranslations.every(
          (t) => t && t.trim()
        );
        if (allBackTranslated) {
          switchToStep(4);
        } else {
          alert("请完成所有段落的回译");
        }

        // 标记为已完成
        saveCurrentTraining(true);
      });

      // 开始新的训练
      elements.newSessionBtn.addEventListener("click", () => {
        // 保存当前训练为已完成
        saveCurrentTraining(true);

        // 重置状态
        state.recordId = null;
        state.originalText = "";
        state.chunks = [];
        state.translations = [];
        state.backTranslations = [];
        state.currentChunkIndex = 0;

        elements.originalText.value = "";

        // 跳转到历史页面
        switchToStep(0);
      });

      // 在页面加载时自动加载历史记录列表
      document.addEventListener("DOMContentLoaded", () => {
        // 添加历史记录按钮到页面顶部
        const headerTitle = document.querySelector("h1");
        const historyButton = document.createElement("button");
        historyButton.className =
          "btn absolute right-4 top-4 text-sm py-1 px-2";
        historyButton.textContent = "训练历史";
        historyButton.addEventListener("click", () => {
          // 只有当有内容且已经开始训练时才保存
          if (hasTrainingContent()) {
            saveCurrentTraining(); // 保存当前进度
          }
          switchToStep(0);
        });
        headerTitle.parentNode.style.position = "relative";
        headerTitle.parentNode.appendChild(historyButton);

        updateNavigationBar();
      });

      // 保存当前训练状态
      function saveCurrentTraining(completed = false) {
        // 创建新记录ID或使用现有ID
        if (!state.recordId) {
          state.recordId = "record_" + Date.now();
        }

        // 根据当前步骤保存数据
        saveCurrentStepData();

        // 创建训练记录对象
        const record = {
          id: state.recordId,
          title: state.title || `训练 ${new Date().toLocaleString()}`, // 使用已有标题或默认标题
          date: new Date().toISOString(),
          originalText: state.originalText,
          chunks: state.chunks,
          translations: state.translations,
          backTranslations: state.backTranslations,
          currentStep: state.currentStep,
          currentChunkIndex: state.currentChunkIndex,
          completed: completed,
        };

        // 保存到本地存储
        storage.saveTrainingRecord(record);

        return record;
      }

      // 修复加载记录函数，使用正确的方法名
      function loadTrainingRecord(id) {
        const record = storage.getRecord(id);
        if (!record) {
          showToast("无法加载记录，可能已被删除");
          return;
        }

        console.log("加载记录:", record);

        // 更新状态 - 确保所有数组都存在且长度匹配
        Object.assign(state, {
          originalText: record.originalText || "",
          chunks: record.chunks || [],
          currentChunkIndex: record.currentChunkIndex || 0,
          translations: record.translations || [],
          backTranslations: record.backTranslations || [],
          currentStep: record.currentStep || 1,
          currentBackIndex: record.currentBackIndex || 0,
          recordId: id,
          title: record.title, // 确保这里设置了title
        });

        // 确保数组长度一致性（这是关键修复）
        if (record.chunks && record.chunks.length > 0) {
          // 确保translations数组与chunks长度匹配
          while (state.translations.length < state.chunks.length) {
            state.translations.push("");
          }

          // 确保backTranslations数组与chunks长度匹配
          while (state.backTranslations.length < state.chunks.length) {
            state.backTranslations.push("");
          }
        }

        // 根据记录的进度决定要显示哪个步骤
        const step = record.completed ? 4 : record.currentStep || 1;

        // 如果是步骤1，需要显示原始文本
        if (step === 1) {
          elements.originalText.value = record.originalText || "";
        }

        // 切换到适当的步骤
        switchToStep(step);

        showToast(`已加载"${record.title}"`);
      }

      // 渲染训练历史列表 - 优化排版和视觉层次
      function renderTrainingHistory() {
        const records = storage.getAllRecords();
        const recordIds = Object.keys(records).sort((a, b) => {
          // 按创建日期倒序排列，最新的在前面
          return new Date(records[b].date) - new Date(records[a].date);
        });

        // 创建顶部区域，包含标题和主要操作按钮
        let historyHTML = `
          <div class="flex justify-between items-center mb-6">
            <h2 class="text-2xl font-bold">训练历史</h2>
            <div class="flex space-x-3">
              <button id="newTrainingBtn" class="btn bg-purple-600 hover:bg-purple-700 text-white px-4 py-2">
                新建训练
              </button>
              <label for="importFile" class="btn bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 cursor-pointer">
                导入训练
                <input type="file" id="importFile" accept=".txt" class="hidden" />
              </label>
            </div>
          </div>
        `;

        // 批量操作工具栏
        historyHTML += `
          <div class="bg-gray-100 dark:bg-gray-800 rounded-t-lg p-3 flex justify-between items-center border-b border-gray-200 dark:border-gray-700">
            <div class="flex items-center">
              <input type="checkbox" id="selectAllRecords" class="w-4 h-4 mr-2 cursor-pointer">
              <label for="selectAllRecords" class="font-medium cursor-pointer">全选</label>
            </div>
            <button id="deleteSelectedBtn" class="btn bg-red-500 hover:bg-red-600 text-white px-3 py-1 text-sm disabled:opacity-50 disabled:cursor-not-allowed" disabled>
              删除所选记录
            </button>
          </div>
        `;

        if (recordIds.length === 0) {
          historyHTML += `
            <div class="bg-white dark:bg-gray-900 border border-gray-200 dark:border-gray-700 rounded-b-lg p-8 text-center">
              <div class="text-gray-400 mb-3">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-12 w-12 mx-auto" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" />
                </svg>
              </div>
              <p class="text-lg mb-2">还没有训练记录</p>
              <p class="text-sm text-gray-500">开始新的训练或导入已有训练记录</p>
            </div>
          `;
          elements.historyList.innerHTML = historyHTML;

          setupEventListeners();
          return;
        }

        // 开始记录列表
        historyHTML += `<div class="bg-white dark:bg-gray-900 rounded-b-lg overflow-hidden shadow divide-y divide-gray-200 dark:divide-gray-700">`;

        recordIds.forEach((id, index) => {
          const record = records[id];
          const date = new Date(record.date).toLocaleString();
          const status = record.completed ? "已完成" : "进行中";
          const statusClass = record.completed
            ? "bg-green-100 dark:bg-green-800 text-green-800 dark:text-green-100"
            : "bg-yellow-100 dark:bg-yellow-800 text-yellow-800 dark:text-yellow-100";

          historyHTML += `
            <div class="record-item hover:bg-gray-50 dark:hover:bg-gray-800 transition-colors" data-id="${id}">
              <div class="p-4">
                <div class="flex items-start">
                  <input type="checkbox" class="record-checkbox mt-1 w-5 h-5 mr-3 cursor-pointer" data-id="${id}">
                  <div class="flex-1">
                    <div class="flex items-center justify-between mb-1">
                      <h3 class="text-lg font-bold">${record.title}</h3>
                      <span class="badge ${statusClass} text-xs px-2 py-1 rounded-full font-medium">${status}</span>
                    </div>
                    <div class="grid grid-cols-2 text-sm text-gray-500 mt-2">
                      <div class="flex items-center">
                        <svg class="w-4 h-4 mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z"></path>
                        </svg>
                        <span>${date}</span>
                      </div>
                      <div class="flex items-center">
                        <svg class="w-4 h-4 mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h7"></path>
                        </svg>
                        <span>段落数: ${
                          record.chunks ? record.chunks.length : 0
                        }</span>
                      </div>
                    </div>
                  </div>
                </div>
                <div class="flex justify-end mt-3 space-x-2">
                  <button class="load-record-btn btn-sm bg-blue-500 hover:bg-blue-600 text-white" data-id="${id}">
                    加载
                  </button>
                  <button class="export-record-btn btn-sm bg-gray-500 hover:bg-gray-600 text-white" data-id="${id}">
                    导出
                  </button>
                  <button class="rename-record-btn btn-sm bg-gray-500 hover:bg-gray-600 text-white" data-id="${id}">
                    重命名
                  </button>
                  <button class="delete-record-btn btn-sm bg-red-500 hover:bg-red-600 text-white" data-id="${id}">
                    删除
                  </button>
                </div>
              </div>
            </div>
          `;
        });

        historyHTML += `</div>`;
        elements.historyList.innerHTML = historyHTML;

        function setupEventListeners() {
          // 新建训练按钮
          const newTrainingBtn = document.getElementById("newTrainingBtn");
          if (newTrainingBtn) {
            newTrainingBtn.addEventListener("click", () => {
              initializeNewTraining();
            });
          }

          // 添加全选事件处理
          const selectAllCheckbox = document.getElementById("selectAllRecords");
          if (selectAllCheckbox) {
            selectAllCheckbox.addEventListener("change", function () {
              const checkboxes = document.querySelectorAll(".record-checkbox");
              checkboxes.forEach((checkbox) => {
                checkbox.checked = this.checked;
              });
              updateDeleteButtonState();
            });
          }

          // 添加复选框变化监听
          document.querySelectorAll(".record-checkbox").forEach((checkbox) => {
            checkbox.addEventListener("change", updateDeleteButtonState);
          });

          // 添加批量删除按钮事件
          const deleteSelectedBtn =
            document.getElementById("deleteSelectedBtn");
          if (deleteSelectedBtn) {
            deleteSelectedBtn.addEventListener("click", deleteSelectedRecords);
          }

          // 添加单个记录操作事件
          document.querySelectorAll(".load-record-btn").forEach((btn) => {
            btn.addEventListener("click", (e) => {
              const recordId = e.target.getAttribute("data-id");
              loadTrainingRecord(recordId);
            });
          });

          document.querySelectorAll(".export-record-btn").forEach((btn) => {
            btn.addEventListener("click", (e) => {
              const recordId = e.target.getAttribute("data-id");
              const record = storage.getRecord(recordId);
              if (record) {
                showExportPreview(record);
              }
            });
          });

          document.querySelectorAll(".rename-record-btn").forEach((btn) => {
            btn.addEventListener("click", (e) => {
              const recordId = e.target.getAttribute("data-id");
              showRenameDialog(recordId);
            });
          });

          document.querySelectorAll(".delete-record-btn").forEach((btn) => {
            btn.addEventListener("click", (e) => {
              const recordId = e.target.getAttribute("data-id");
              showDeleteConfirmation(recordId);
            });
          });

          // 设置导入文件事件监听器
          setupImportListener();
        }

        setupEventListeners();
      }

      // 更新删除按钮状态
      function updateDeleteButtonState() {
        const selectedCheckboxes = document.querySelectorAll(
          ".record-checkbox:checked"
        );
        const deleteBtn = document.getElementById("deleteSelectedBtn");

        if (selectedCheckboxes.length > 0) {
          deleteBtn.removeAttribute("disabled");
          deleteBtn.textContent = `删除所选(${selectedCheckboxes.length})`;
        } else {
          deleteBtn.setAttribute("disabled", "disabled");
          deleteBtn.textContent = "删除所选记录";
        }
      }

      // 删除选中的记录
      function deleteSelectedRecords() {
        const selectedCheckboxes = document.querySelectorAll(
          ".record-checkbox:checked"
        );

        if (selectedCheckboxes.length === 0) return;

        // 创建确认对话框
        const overlay = document.createElement("div");
        overlay.className =
          "fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50";

        const dialog = document.createElement("div");
        dialog.className =
          "bg-white dark:bg-gray-800 rounded-lg p-6 max-w-md w-full";

        dialog.innerHTML = `
          <h3 class="text-xl font-bold mb-4">确认批量删除</h3>
          <p class="mb-6">您确定要删除选中的 ${selectedCheckboxes.length} 条训练记录吗？此操作不可撤销。</p>
          <div class="flex justify-end gap-2">
            <button id="cancelBatchDeleteBtn" class="btn bg-gray-500">取消</button>
            <button id="confirmBatchDeleteBtn" class="btn bg-red-500">确认删除</button>
          </div>
        `;

        overlay.appendChild(dialog);
        document.body.appendChild(overlay);

        // 取消按钮事件
        document
          .getElementById("cancelBatchDeleteBtn")
          .addEventListener("click", () => {
            document.body.removeChild(overlay);
          });

        // 确认删除按钮事件
        document
          .getElementById("confirmBatchDeleteBtn")
          .addEventListener("click", () => {
            // 收集所有要删除的ID
            const idsToDelete = [];
            selectedCheckboxes.forEach((checkbox) => {
              idsToDelete.push(checkbox.getAttribute("data-id"));
            });

            // 执行删除
            idsToDelete.forEach((id) => {
              storage.deleteRecord(id);
            });

            // 关闭对话框
            document.body.removeChild(overlay);

            // 显示成功消息
            showToast(`已删除 ${idsToDelete.length} 条训练记录`);

            // 重新渲染历史记录
            renderTrainingHistory();
          });
      }

      // 单条记录删除确认
      function showDeleteConfirmation(recordId) {
        const record = storage.getRecord(recordId);
        if (!record) return;

        const overlay = document.createElement("div");
        overlay.className =
          "fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50";

        const dialog = document.createElement("div");
        dialog.className =
          "bg-white dark:bg-gray-800 rounded-lg p-6 max-w-md w-full";

        dialog.innerHTML = `
          <h3 class="text-xl font-bold mb-4">确认删除</h3>
          <p class="mb-6">您确定要删除"${record.title}"吗？此操作不可撤销。</p>
          <div class="flex justify-end gap-2">
            <button id="cancelDeleteBtn" class="btn bg-gray-500">取消</button>
            <button id="confirmDeleteBtn" class="btn bg-red-500">确认删除</button>
          </div>
        `;

        overlay.appendChild(dialog);
        document.body.appendChild(overlay);

        document
          .getElementById("cancelDeleteBtn")
          .addEventListener("click", () => {
            document.body.removeChild(overlay);
          });

        document
          .getElementById("confirmDeleteBtn")
          .addEventListener("click", () => {
            storage.deleteRecord(recordId);
            document.body.removeChild(overlay);
            showToast("已删除训练记录");
            renderTrainingHistory();
          });
      }

      // 计算训练进度百分比
      function calculateTrainingProgress(record) {
        if (record.completed) return 100;

        const totalSteps = 3; // 总共3个步骤（不包括初始输入）
        let progress = 0;

        if (record.currentStep > 1) {
          progress += (record.currentStep - 1) * 33.3; // 每个完成的步骤占33.3%
        }

        // 计算当前步骤内的进度
        if (record.chunks.length > 0) {
          const stepProgress =
            (record.currentChunkIndex / record.chunks.length) * 33.3;
          progress += stepProgress;
        }

        return Math.min(Math.round(progress), 99); // 仅在标记为completed时才显示100%
      }

      // 新建训练按钮事件
      document
        .getElementById("newTrainingBtn")
        .addEventListener("click", () => {
          state.recordId = null;
          state.originalText = "";
          state.chunks = [];
          state.translations = [];
          state.backTranslations = [];
          state.currentChunkIndex = 0;

          elements.originalText.value = "";
          switchToStep(1);
        });

      // 在每次切换步骤时自动保存进度
      const originalSwitchToStep = switchToStep;
      switchToStep = function (step) {
        // 如果从任何状态切换，先保存当前输入的数据
        saveCurrentStepData();

        // 然后保存整个训练记录，但只在有内容时保存
        if (
          state.currentStep >= 1 &&
          state.currentStep <= 4 &&
          hasTrainingContent()
        ) {
          saveCurrentTraining();
        }

        // 调用原始函数
        originalSwitchToStep(step);
      };

      // 添加导出相关函数

      // 格式化导出内容 - 修复逐句对比部分但保留原始格式
      function formatExportContent(specificRecord = null) {
        const dateStr = new Date().toLocaleDateString();

        // 使用当前状态或指定的记录
        const record = specificRecord || {
          originalText: state.originalText,
          chunks: state.chunks,
          translations: state.translations,
          backTranslations: state.backTranslations,
        };

        // 准备导出的三个部分内容
        let translationPart = `翻译（${dateStr}）：\n`;
        let backTranslationPart = `\n\n回译（${dateStr}）：\n`;
        let comparisonPart = `\n\n前后逐句对比：\n`;

        // 创建翻译部分 - 按块组织
        for (let i = 0; i < record.chunks.length; i++) {
          translationPart +=
            record.chunks[i] + "\n" + record.translations[i] + "\n";
        }

        // 创建回译部分 - 按块组织
        for (let i = 0; i < record.chunks.length; i++) {
          backTranslationPart +=
            record.translations[i] + "\n" + record.backTranslations[i] + "\n";
        }

        // 修复：创建对比部分 - 按句子组织，正确处理分段
        let allOriginalSentences = [];
        let allBackSentences = [];

        // 按段落处理文本，保持句子的原始上下文
        for (let i = 0; i < record.chunks.length; i++) {
          const originalChunk = record.chunks[i] || "";
          const backChunk = record.backTranslations[i] || "";

          if (!originalChunk || !backChunk) continue;

          // 提取每个块中的句子
          const originalSentences = extractSentences(originalChunk);
          const backSentences = extractSentences(backChunk);

          // 逐句添加到数组
          originalSentences.forEach((sentence) => {
            if (sentence.trim()) allOriginalSentences.push(sentence.trim());
          });

          backSentences.forEach((sentence) => {
            if (sentence.trim()) allBackSentences.push(sentence.trim());
          });
        }

        // 比较并格式化句子
        const sentenceCount = Math.min(
          allOriginalSentences.length,
          allBackSentences.length
        );

        for (let i = 0; i < sentenceCount; i++) {
          const originalSentence = allOriginalSentences[i];
          const backSentence = allBackSentences[i];

          comparisonPart += originalSentence + "\n" + backSentence + "\n\n";
        }

        return translationPart + backTranslationPart + comparisonPart;
      }

      // 导出为txt文件
      function exportAsTxt(specificRecord = null) {
        const record = specificRecord || {
          title: state.title || `回译训练_${new Date().toLocaleDateString()}`,
          originalText: state.originalText,
          chunks: state.chunks,
          translations: state.translations,
          backTranslations: state.backTranslations,
        };

        // 确保title字段存在
        if (!record.title) {
          record.title = `回译训练_${new Date().toLocaleDateString()}`;
        }

        const content = formatExportContent(record);

        // 使用记录标题作为文件名，不添加日期
        let filename = record.title;

        // 确保文件名是有效的，去除非法字符
        filename = filename.replace(/[<>:"/\\|?*]/g, "_");

        // 只添加扩展名
        filename = `${filename}.txt`;

        try {
          // 创建blob并下载
          const blob = new Blob([content], {
            type: "text/plain;charset=utf-8",
          });

          // 使用saveAs方法提供更好的下载体验
          if (window.navigator && window.navigator.msSaveOrOpenBlob) {
            // 对IE和Edge的特殊处理
            window.navigator.msSaveOrOpenBlob(blob, filename);
          } else {
            // 对其他浏览器的处理
            const url = URL.createObjectURL(blob);
            const link = document.createElement("a");
            link.href = url;
            link.download = filename;
            link.style.display = "none";
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            setTimeout(() => URL.revokeObjectURL(url), 100);
          }

          showToast("文件已成功导出");
        } catch (error) {
          console.error("导出文件时出错:", error);
          showToast("导出失败: " + (error.message || "未知错误"));

          // 尝试提供一个备选方案
          try {
            const textArea = document.createElement("textarea");
            textArea.value = content;
            textArea.style.position = "fixed";
            textArea.style.top = "0";
            textArea.style.left = "0";
            textArea.style.width = "100%";
            textArea.style.height = "100%";
            textArea.style.zIndex = "9999";
            document.body.appendChild(textArea);
            textArea.focus();
            textArea.select();
            showToast("请手动全选内容(Ctrl+A)并复制(Ctrl+C)保存");
          } catch (e) {
            console.error("备选方案也失败了:", e);
          }
        }
      }

      // 复制到剪贴板
      function copyToClipboard(specificRecord = null) {
        const content = formatExportContent(specificRecord);

        // 使用现代clipboard API
        if (navigator.clipboard && navigator.clipboard.writeText) {
          navigator.clipboard
            .writeText(content)
            .then(() => {
              showToast("已复制到剪贴板");
            })
            .catch((err) => {
              console.error("复制失败:", err);
              fallbackCopy(content);
            });
        } else {
          fallbackCopy(content);
        }
      }

      // 剪贴板复制的后备方案
      function fallbackCopy(text) {
        // 创建临时文本区域
        const textArea = document.createElement("textarea");
        textArea.value = text;
        textArea.style.position = "fixed";
        textArea.style.left = "-999999px";
        textArea.style.top = "-999999px";
        document.body.appendChild(textArea);
        textArea.focus();
        textArea.select();

        try {
          const successful = document.execCommand("copy");
          if (successful) {
            showToast("已复制到剪贴板");
          } else {
            showToast("复制失败，请手动复制");
          }
        } catch (err) {
          console.error("复制失败:", err);
          showToast("复制失败，请手动复制");
        }

        document.body.removeChild(textArea);
      }

      // 显示提示信息
      function showToast(message) {
        // 检查是否已存在toast元素
        let toast = document.getElementById("toast-notification");
        if (toast) {
          document.body.removeChild(toast);
        }

        // 创建新的toast元素
        toast = document.createElement("div");
        toast.id = "toast-notification";
        toast.className =
          "fixed bottom-4 right-4 bg-gray-800 text-white px-4 py-2 rounded shadow-lg";
        toast.textContent = message;

        document.body.appendChild(toast);

        // 3秒后移除
        setTimeout(() => {
          if (document.body.contains(toast)) {
            document.body.removeChild(toast);
          }
        }, 3000);
      }

      // 显示导出预览对话框
      function showExportPreview(specificRecord = null) {
        // 使用当前状态或指定的记录
        const record = specificRecord || {
          title: state.title || `回译训练_${new Date().toLocaleDateString()}`, // 添加标题
          originalText: state.originalText,
          chunks: state.chunks,
          translations: state.translations,
          backTranslations: state.backTranslations,
        };

        // 创建预览对话框
        const overlay = document.createElement("div");
        overlay.className =
          "fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50";

        const dialog = document.createElement("div");
        dialog.className =
          "bg-white dark:bg-gray-800 rounded-lg p-6 max-w-3xl w-full max-h-[80vh] overflow-auto relative";

        const closeBtn = document.createElement("button");
        closeBtn.className =
          "absolute top-2 right-2 text-gray-500 hover:text-gray-700";
        closeBtn.innerHTML = "&times;";
        closeBtn.onclick = () => document.body.removeChild(overlay);

        const title = document.createElement("h3");
        title.className = "text-xl font-bold mb-4 pr-8";
        title.textContent = "导出预览";

        const content = document.createElement("pre");
        content.className =
          "whitespace-pre-wrap text-sm bg-gray-100 dark:bg-gray-700 p-4 rounded max-h-[50vh] overflow-auto";
        content.textContent = formatExportContent(record);

        const actions = document.createElement("div");
        actions.className = "flex mt-4 gap-2 justify-end";

        const copyBtn = document.createElement("button");
        copyBtn.className = "btn bg-blue-500";
        copyBtn.textContent = "复制内容";
        copyBtn.onclick = () => {
          copyToClipboard(record);
        };

        const downloadBtn = document.createElement("button");
        downloadBtn.className = "btn";
        downloadBtn.textContent = "下载TXT文件";
        downloadBtn.onclick = () => {
          document.body.removeChild(overlay); // 先关闭预览窗口
          setTimeout(() => exportAsTxt(record), 100); // 延迟执行导出，避免冲突
        };

        actions.appendChild(copyBtn);
        actions.appendChild(downloadBtn);

        dialog.appendChild(closeBtn);
        dialog.appendChild(title);
        dialog.appendChild(content);
        dialog.appendChild(actions);

        overlay.appendChild(dialog);
        document.body.appendChild(overlay);
      }

      // 添加导出按钮事件处理
      document.getElementById("exportBtn").addEventListener("click", () => {
        showExportPreview();
      });

      // 显示重命名对话框
      function showRenameDialog(recordId) {
        const record = storage.getRecord(recordId);
        if (!record) return;

        // 创建对话框
        const overlay = document.createElement("div");
        overlay.className =
          "fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50";

        const dialog = document.createElement("div");
        dialog.className =
          "bg-white dark:bg-gray-800 rounded-lg p-6 max-w-md w-full";

        const title = document.createElement("h3");
        title.className = "text-xl font-bold mb-4";
        title.textContent = "重命名训练记录";

        const inputGroup = document.createElement("div");
        inputGroup.className = "mb-4";

        const input = document.createElement("input");
        input.type = "text";
        input.className = "w-full p-2 border rounded";
        input.value = record.title;
        input.placeholder = "输入新名称";

        inputGroup.appendChild(input);

        const actions = document.createElement("div");
        actions.className = "flex justify-end gap-2";

        const cancelBtn = document.createElement("button");
        cancelBtn.className = "btn bg-gray-500";
        cancelBtn.textContent = "取消";
        cancelBtn.onclick = () => document.body.removeChild(overlay);

        const saveBtn = document.createElement("button");
        saveBtn.className = "btn";
        saveBtn.textContent = "保存";
        saveBtn.onclick = () => {
          const newTitle = input.value.trim();
          if (newTitle) {
            // 更新记录标题
            record.title = newTitle;
            storage.saveTrainingRecord(record);

            // 如果当前正在编辑这个记录，也更新state
            if (state.recordId === recordId) {
              state.title = newTitle; // 修改这里，使用state.title而不是state.recordTitle
            }

            // 刷新历史列表
            renderTrainingHistory();

            // 关闭对话框
            document.body.removeChild(overlay);

            // 显示成功提示
            showToast("已重命名训练记录");
          } else {
            alert("请输入有效的名称");
          }
        };

        actions.appendChild(cancelBtn);
        actions.appendChild(saveBtn);

        dialog.appendChild(title);
        dialog.appendChild(inputGroup);
        dialog.appendChild(actions);

        overlay.appendChild(dialog);
        document.body.appendChild(overlay);

        // 聚焦到输入框
        setTimeout(() => input.focus(), 100);
      }

      // 设置导入按钮事件监听器
      function setupImportListener() {
        const importFileInput = document.getElementById("importFile");
        if (importFileInput) {
          importFileInput.addEventListener("change", handleFileImport);
        }
      }

      // 解析导入的内容 - 更新逻辑更加健壮
      function parseImportedContent(content) {
        // 添加调试信息
        console.log("开始解析导入内容");
        console.log("内容长度:", content.length);

        // 尝试识别三个部分
        let translationPart = "";
        let backTranslationPart = "";
        let comparisonPart = "";

        // 首先，确保内容不为空
        if (!content || content.trim().length === 0) {
          console.error("导入内容为空");
          return null;
        }

        // 寻找分隔标记
        const translationMatch = content.match(/^翻译.*?：\n/);
        const backTranslationMatch = content.match(/\n\n回译.*?：\n/);
        const comparisonMatch = content.match(/\n\n前后逐句对比.*?：\n/);

        console.log("匹配结果:", {
          trans: !!translationMatch,
          backTrans: !!backTranslationMatch,
          comparison: !!comparisonMatch,
        });

        // 如果找不到必要的分隔标记，尝试一种简化的解析方法
        if (!translationMatch || !backTranslationMatch) {
          console.log("无法找到标准格式标记，尝试简化解析");
          return parseSimplifiedContent(content);
        }

        // 提取三个部分
        const transStart = translationMatch.index + translationMatch[0].length;
        const backTransStart =
          backTranslationMatch.index + backTranslationMatch[0].length;
        const comparisonStart = comparisonMatch
          ? comparisonMatch.index + comparisonMatch[0].length
          : content.length;

        translationPart = content.substring(
          transStart,
          backTranslationMatch.index
        );
        backTranslationPart = content.substring(
          backTransStart,
          comparisonMatch ? comparisonMatch.index : content.length
        );

        console.log("分割部分长度:", {
          trans: translationPart.length,
          backTrans: backTranslationPart.length,
        });

        // 解析翻译部分，提取原文块和翻译
        const chunks = [];
        const translations = [];

        const translationLines = translationPart.split("\n");
        for (let i = 0; i < translationLines.length; i += 2) {
          if (i + 1 < translationLines.length) {
            const chunk = translationLines[i].trim();
            const translation = translationLines[i + 1].trim();

            if (chunk && translation) {
              chunks.push(chunk);
              translations.push(translation);
            }
          }
        }

        // 解析回译部分，提取回译文本
        const backTranslations = [];
        const backTranslationLines = backTranslationPart.split("\n");

        let currentTranslationIndex = 0;
        for (let i = 0; i < backTranslationLines.length; i++) {
          const line = backTranslationLines[i].trim();

          // 跳过空行
          if (!line) continue;

          // 如果这一行与翻译中的某一行匹配，则下一行应该是对应的回译
          if (
            i + 1 < backTranslationLines.length &&
            translations.includes(line)
          ) {
            const backTranslation = backTranslationLines[i + 1].trim();
            if (backTranslation) {
              backTranslations.push(backTranslation);
              i++; // 跳过下一行，因为已经处理过了
            }
          }
        }

        // 如果上面的方法没有找到任何回译，尝试简单的偶数行提取方法
        if (backTranslations.length === 0) {
          for (let i = 1; i < backTranslationLines.length; i += 2) {
            if (i < backTranslationLines.length) {
              const backTranslation = backTranslationLines[i].trim();
              if (backTranslation) {
                backTranslations.push(backTranslation);
              }
            }
          }
        }

        console.log("解析结果:", {
          chunks: chunks.length,
          translations: translations.length,
          backTranslations: backTranslations.length,
        });

        // 确保回译数组长度与翻译数组长度一致，未完成的部分用空字符串填充
        while (backTranslations.length < chunks.length) {
          backTranslations.push(""); // 未完成的回译用空字符串填充
        }

        // 确保所有数组长度一致
        const minLength = Math.min(
          chunks.length,
          translations.length,
          backTranslations.length
        );

        if (minLength === 0) {
          console.error("无法从内容中提取有效数据");
          return null;
        }

        // 截取相同长度
        const finalChunks = chunks.slice(0, minLength);
        const finalTranslations = translations.slice(0, minLength);
        const finalBackTranslations = backTranslations.slice(0, minLength);

        // 合并原文块以获得完整原文
        const originalText = finalChunks.join(" ");

        return {
          originalText,
          chunks: finalChunks,
          translations: finalTranslations,
          backTranslations: finalBackTranslations,
        };
      }

      // 尝试使用简化方法解析内容
      function parseSimplifiedContent(content) {
        console.log("使用简化方法解析内容");

        // 按行分割
        const lines = content
          .split("\n")
          .filter((line) => line.trim().length > 0);

        if (lines.length < 6) {
          // 至少需要2组数据，每组3行
          console.error("行数不足，无法解析");
          return null;
        }

        const chunks = [];
        const translations = [];
        const backTranslations = [];

        // 尝试识别模式
        // 假设文件中的内容是按块组织的：原文、翻译、回译，以及可能的空行
        for (let i = 0; i < lines.length - 2; i++) {
          const potentialChunk = lines[i].trim();
          const potentialTranslation = lines[i + 1].trim();
          const potentialBackTranslation = lines[i + 2].trim();

          // 检查这三行是否形成有效的数据组
          // 原文应该包含英文字符，翻译应该包含中文字符，回译应该包含英文字符
          const hasEnglish = (text) => /[a-zA-Z]/.test(text);
          const hasChinese = (text) => /[\u4e00-\u9fa5]/.test(text);

          if (
            hasEnglish(potentialChunk) &&
            hasChinese(potentialTranslation) &&
            hasEnglish(potentialBackTranslation)
          ) {
            chunks.push(potentialChunk);
            translations.push(potentialTranslation);
            backTranslations.push(potentialBackTranslation);
            i += 2; // 跳过已处理的行
          }
        }

        console.log("简化解析结果:", {
          chunks: chunks.length,
          translations: translations.length,
          backTranslations: backTranslations.length,
        });

        if (chunks.length === 0) {
          console.error("简化解析无法提取有效数据");
          return null;
        }

        // 合并原文块以获得完整原文
        const originalText = chunks.join(" ");

        return {
          originalText,
          chunks,
          translations,
          backTranslations,
        };
      }

      // 处理文件导入 - 添加更多错误处理和用户反馈
      function handleFileImport(event) {
        const file = event.target.files[0];
        if (!file) return;

        const reader = new FileReader();

        reader.onload = function (e) {
          try {
            const content = e.target.result;

            // 不修改原有状态对象，而是先获取解析结果
            const importData = parseImportedContent(content);

            if (importData) {
              // 使用文件名作为标题
              const fileName = file.name.replace(/\.[^/.]+$/, "");

              // 判断完成状态
              const isCompleted =
                importData.backTranslations &&
                importData.chunks &&
                importData.backTranslations.length ===
                  importData.chunks.length &&
                importData.backTranslations.every(
                  (bt) => bt && bt.trim().length > 0
                );

              // 更新状态属性
              Object.assign(state, {
                originalText: importData.originalText || "",
                chunks: importData.chunks || [],
                translations: importData.translations || [],
                backTranslations: importData.backTranslations || [],
                currentChunkIndex: 0,
                currentBackIndex: 0,
                currentStep: isCompleted ? 4 : 1, // 如果完成了，设置为比较步骤
                title: fileName,
                recordId: null, // 确保创建新记录
              });

              // 保存状态
              const savedRecord = saveCurrentState(isCompleted);

              showToast(`成功导入 "${fileName}"`);

              // 根据状态显示界面 - 修复：使用switchToStep而不是setupComparisonView
              if (isCompleted) {
                switchToStep(4); // 使用步骤4（比较页面）而不是undefined的函数
              } else {
                switchToStep(1);
              }
            } else {
              showToast("无法解析导入的文件");
            }
          } catch (error) {
            console.error("导入文件时出错:", error);
            showToast("导入失败: " + (error.message || "格式错误"));
          }

          // 重置文件输入框
          event.target.value = "";
        };

        reader.readAsText(file);
      }

      // 修复保存记录函数，确保保留加载的原始标题
      function saveCurrentState(completed = false) {
        const currentTime = new Date().toISOString();

        // 如果不存在记录ID，创建新记录
        if (!state.recordId) {
          state.recordId = `record_${Date.now()}`;

          // 只有新记录才使用默认标题，否则保留原有标题
          if (!state.title) {
            state.title = `回译训练_${new Date().toLocaleDateString()}`;
          }
        }

        const record = {
          id: state.recordId,
          title: state.title, // 使用状态中保存的标题
          originalText: state.originalText,
          chunks: state.chunks,
          translations: state.translations,
          backTranslations: state.backTranslations,
          currentChunkIndex: state.currentChunkIndex,
          currentBackIndex: state.currentBackIndex,
          currentStep: state.currentStep,
          date: currentTime,
          completed: completed,
        };

        // 修复：使用正确的方法名 saveTrainingRecord 而不是 saveRecord
        storage.saveTrainingRecord(record);

        return record;
      }

      // 添加一个函数来检查是否有需要保存的训练内容
      function hasTrainingContent() {
        // 如果没有记录ID或者是第一步但内容为空，则认为没有开始训练
        if (!state.recordId) {
          return false;
        }

        // 如果在第一步，但有内容
        if (
          state.currentStep === 1 &&
          state.originalText &&
          state.originalText.trim() !== ""
        ) {
          return true;
        }

        // 如果已经开始翻译或后续步骤
        if (state.currentStep > 1) {
          return true;
        }

        // 如果已有翻译或回译内容
        if (
          state.translations &&
          state.translations.some((t) => t && t.trim() !== "")
        ) {
          return true;
        }

        if (
          state.backTranslations &&
          state.backTranslations.some((t) => t && t.trim() !== "")
        ) {
          return true;
        }

        return false;
      }

      // 添加初始化新训练的函数
      function initializeNewTraining() {
        state.recordId = null;
        state.originalText = "";
        state.chunks = [];
        state.translations = [];
        state.backTranslations = [];
        state.currentChunkIndex = 0;
        state.title = null;

        elements.originalText.value = "";
        switchToStep(1);
      }
    </script>
  </body>
</html>
